import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { liveQuery } from 'dexie'
import { useDB } from '@/composables/useDB'
import type { TimeEntry } from '@/utils/db'

export const useTimeEntriesStore = defineStore('timeEntries', () => {
  const { db } = useDB() || {}
  const entries = ref<TimeEntry[]>([])

  // Initialize live query if client-side and db is available
  if (process.client && db) {
    liveQuery(() => db.timeEntries.toArray())
      .subscribe({
        next: (data) => {
          entries.value = data
        },
        error: (err) => {
          console.error('[TimeEntries Store] Live query error:', err)
        }
      })
  }

  // Debug logging helper
  const logDebug = (action: string, data?: any) => {
    const timestamp = new Date().toISOString()
    console.log(`[TimeEntries Store] ${timestamp} - ${action}`, data || '')
  }

  // Actions
  const addEntry = async (entry: Omit<TimeEntry, 'id'>) => {
    if (!db) return

    try {
      const id = await db.timeEntries.add(entry as TimeEntry)
      logDebug('Entry added successfully', { id, date: entry.date })
      return id
    } catch (error) {
      console.error('[TimeEntries Store] Failed to add entry:', error)
      throw error
    }
  }

  const updateEntry = async (id: string, updates: Partial<TimeEntry>) => {
    if (!db) return

    try {
      await db.timeEntries.update(id, updates)
      logDebug('Entry updated successfully', { id })
    } catch (error) {
      console.error('[TimeEntries Store] Failed to update entry:', error)
      throw error
    }
  }

  // Getters
  const getEntriesForDay = (date: string) => {
    return entries.value.filter(e => e.date === date)
  }

  const getTotalDurationForDay = (date: string) => {
    const dayEntries = getEntriesForDay(date)
    return dayEntries.reduce((total, entry) => {
      const end = entry.endTime || Date.now()
      return total + (end - entry.startTime)
    }, 0)
  }

  const saveEntryForDay = async (date: string, data: Omit<TimeEntry, 'id' | 'date'>) => {
    if (!db) return

    logDebug('saveEntryForDay called', { date, data })
    
    // Check if entry exists for this day (logic preserved from original)
    // Note: This logic assumes one entry per day or updates the first one found.
    // Ideally should be more robust, but kept consistent with legacy behavior for now.
    const dayEntries = getEntriesForDay(date)
    
    if (dayEntries.length > 0) {
      const firstEntry = dayEntries[0]
      if (firstEntry && firstEntry.id) {
        logDebug('Existing entry found, updating', { id: firstEntry.id })
        await updateEntry(firstEntry.id, data)
      }
    } else {
      logDebug('No existing entry, creating new')
      await addEntry({
        ...data,
        date,
        autoGenerated: false,
        isOvertime: data.isOvertime || false,
        tasks: data.tasks || '',
        modifiedAt: Date.now()
      })
    }
  }

  return {
    entries,
    addEntry,
    updateEntry,
    saveEntryForDay,
    getEntriesForDay,
    getTotalDurationForDay
  }
})

