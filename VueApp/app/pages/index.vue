<template>
  <div class="relative w-full max-w-md h-screen flex flex-col bg-base-100 overflow-y-auto mx-auto">
    <HomeHeader :sync-status="syncStatus" />

    <main class="flex-1 flex flex-col gap-8 pb-40">
      <DailySummary :duration-ms="todaysDuration" />

      <Timeline :entries="todaysEntries" @edit-entry="openAddModal" @add-entry="openAddModal()" />

      <WeekIndicator 
        :selected-date="selectedDate"
        @select-day="handleSelectDay"
      />
    </main>

    <BottomNav @add="openAddModal" />

    <AddEntryModal ref="addModal" :selected-date="selectedDate" @save="handleSaveEntry" />
    

  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useTimeEntriesStore } from '@/stores/timeEntries'
import HomeHeader from '@/components/home/HomeHeader.vue'
import DailySummary from '@/components/home/DailySummary.vue'
import Timeline from '@/components/home/Timeline.vue'
import WeekIndicator from '@/components/home/WeekIndicator.vue'
import BottomNav from '@/components/layout/BottomNav.vue'
import AddEntryModal from '@/components/entry/AddEntryModal.vue'


const store = useTimeEntriesStore()
const addModal = ref<InstanceType<typeof AddEntryModal> | null>(null)
const selectedDate = ref<string>(new Date().toISOString().split('T')[0] || '')
const syncStatus = ref<'synced' | 'syncing' | 'offline'>('synced')

const todaysEntries = computed(() => store.getEntriesForDay(selectedDate.value))
const todaysDuration = computed(() => store.getTotalDurationForDay(selectedDate.value))

const openAddModal = (entryToEdit?: any) => {
  // If entryToEdit has an id, it's a real entry from the timeline.
  if (entryToEdit && entryToEdit.id) {
    addModal.value?.open(entryToEdit)
    return
  }

  // Otherwise (like clicking the + button), calculate the next available slot
  const entries = todaysEntries.value || []
  let nextStartTime = null
  let nextEndTime = null
  
  if (entries.length > 0) {
    // Find the entry with the latest end time
    // Sort by end time just to be safe, though they should be sorted
    const sortedDetails = [...entries].sort((a, b) => a.endTime - b.endTime)
    const lastEntry = sortedDetails[sortedDetails.length - 1]
    
    if (lastEntry) {
        // Start next entry at the end of the last one
        nextStartTime = lastEntry.endTime
        // Default duration 1 hour
        nextEndTime = nextStartTime + (60 * 60 * 1000)
    }
  }

  // Pass a "draft" entry with calculated times but no ID
  const draftEntry = nextStartTime ? {
      startTime: nextStartTime,
      endTime: nextEndTime
  } : null

  addModal.value?.open(draftEntry)
}

const handleSelectDay = (date: string) => {
  selectedDate.value = date
}

const handleSaveEntry = async (payload: any) => {
  console.log('[Index Page] handleSaveEntry called', { payload, selectedDate: selectedDate.value })
  
  // payload: { date, startTime, endTime, hoursWorked, tasks, isWeekend, ... } 
  // startTime/endTime are strings "HH:mm"
  
  const [startHour, startMinute] = payload.startTime.split(':').map(Number)
  const [endHour, endMinute] = payload.endTime.split(':').map(Number)

  if (
    startHour === undefined || startMinute === undefined || 
    endHour === undefined || endMinute === undefined
  ) {
    console.error('[Index Page] Invalid time values', { startHour, startMinute, endHour, endMinute })
    return
  }

  const date = new Date(selectedDate.value)
  
  const startTime = new Date(date)
  startTime.setHours(startHour, startMinute, 0, 0)

  // Handle overnight: if end time < start time (e.g. 02:00 < 22:00), it's next day
  const endTime = new Date(date)
  endTime.setHours(endHour, endMinute, 0, 0)
  
  if (endTime < startTime) {
      endTime.setDate(endTime.getDate() + 1);
  }

  console.log('[Index Page] Prepared time data', {
    date: selectedDate.value,
    startTime: startTime.toLocaleString(),
    endTime: endTime.toLocaleString(),
    startTimestamp: startTime.getTime(),
    endTimestamp: endTime.getTime(),
    tasks: payload.tasks,
    isOvertime: payload.isWeekend
  })

  try {
    await store.saveEntryForDay(selectedDate.value, {
      id: payload.id, // Pass id if present for update
      startTime: startTime.getTime(),
      endTime: endTime.getTime(),
      tasks: payload.tasks,
      isOvertime: payload.isWeekend,
      autoGenerated: false,
      modifiedAt: Date.now()
    })
    
    console.log('[Index Page] Save completed successfully')
  } catch (err) {
    console.error('[Index Page] Failed to save entry:', err)
  }
}
</script>
